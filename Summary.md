(volatile) boolean is atomic

####НУЖНО СИНХРОНИЗИРОВАТЬ: 
1. Когда данные пишутся в переменную которая может быть прочитана другим потоком,
2. Когда читаешь данные которые могут быть записаны другим потоком
3. Читающий и пишущий потоки должны быть синхронизированы по одной блокировке

Lock позволяет создавать hand-over-hand locking (создание структуры синхронизации цепная блокировка)

Правило Гетца: Если ты можешь сам написать высокопроизводительную VM тогда можешь задуматься о том как можно писать код без синхронизации

JVM Может записать long или double в две операции по 32 байта, это может вызвать разрыв слов (атомарность можно обеспечить volatile, только после java5) но на это лучше не надеятся

volatile не гарантирует атомарности когда значение переменной зависит от предидущего значения (i++) или от других полей lower <= upper

volatile безопасно только в том случае если клас содержит только одно изменяемое поле (хотя вся эта маги я сопряжена с рисками)

поле следует объявлять как volatile когда к полю обращаются несколько потогов и по крайней мере один из них изменяет его (иначе можно напороться на локальные кеши потоков)

####Состояния потоков
1. **New** Создание новой нити на этой стадии получаются все необходимые системные ресурсы и право на выделение процессорного времени далее поток переводится планировщиком в runnable or bloked состояние
2. **Runnable** поток не blocked и не dead когда у планировщика появятся свободные кванты он может выполнится
3. **Blocked** поток не dead но процессор не выделяет ему квантов времени
4. **Dead** задача потока завершена и он не может стать активным
####Переход потока в Blocked
* sleep()
* wait()
* поток ожидает некоторого ввода-вывода
* поток пытается вызвать synchronized метод или секцию когда она заблокирована другим потоком

interrupted() или InterruptedException сбрасывает флаг isInterrupted()

IOBlocks and SynchronizedBlocks не прерываются методом Thread.interrupt() для этого можно закрыть ресурс

NIO позволяет прерывать IO блокировки 

ReentrantLock.lockInterruptibly() можно прерывать методом Thread.interrupt()

для освобождения ресурсов всегда вызывае их в блоке try-finally

